<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ECU Map Editor Pro - 2026</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body { font-family: sans-serif; background: #121212; color: #e0e0e0; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        #top-section { height: 60vh; display: flex; padding: 10px; background: #1a1a1a; border-bottom: 2px solid #333; box-sizing: border-box; }
        #chart-container { flex-grow: 1; background: #000; border-radius: 8px; min-width: 0; }
        #chart-controls { width: 220px; padding: 15px; background: #252525; border-radius: 8px; margin-left: 10px; font-size: 14px; flex-shrink: 0; }
        
        /* 表エリア：縦横両方向のスナップを設定 */
        #bottom-section { 
            height: 40vh; 
            overflow: auto; /* 両方向にスクロール可能 */
            padding: 0 10px 10px 10px; 
            background: #121212; 
            box-sizing: border-box;
            scroll-snap-type: both mandatory; /* 縦横両方のスナップを強制 */
        }
        
        .grid-container { display: grid; grid-template-columns: 80px repeat(20, 55px); gap: 1px; background: #444; width: max-content; }
        
        /* セル：スナップの停止位置 */
        .cell { 
            background: #222; 
            height: 28px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 12px;
            scroll-snap-align: start; /* セルの角で止まる */
        }
        
        .header-cell { background: #333 !important; font-weight: bold; color: #00ffcc; font-size: 10px; position: sticky; top: 0; z-index: 3; }
        .label-cell { background: #333 !important; font-weight: bold; position: sticky; left: 0; z-index: 2; text-align: right; padding-right: 5px; }
        .corner-cell { position: sticky; top: 0; left: 0; z-index: 4; border-right: 1px solid #444; }

        .cell input { width: 100%; height: 100%; border: none; text-align: center; background: transparent; color: inherit; font-size: 13px; outline: none; }
        .cross-highlight { background: #2a3d2a !important; }
        .selected-cell { background: #00ffcc !important; color: #000 !important; font-weight: bold; }
        h3 { margin: 0 0 10px 0; color: #00ffcc; font-size: 16px; }
        label { display: block; margin: 8px 0; cursor: pointer; }
    </style>
</head>
<body>

<div id="top-section">
    <div id="chart-container"></div>
    <div id="chart-controls">
        <h3>Graph Mode</h3>
        <div class="control-group">
            <label><input type="radio" name="viewMode" value="tps" checked> 1: 固定回転数 (vs TPS)</label>
            <label><input type="radio" name="viewMode" value="rpm"> 2: 固定TPS (vs RPM)</label>
            <label><input type="radio" name="viewMode" value="3d"> 3: 3Dビュー</label>
        </div>
        <div id="slice-info" style="font-size: 12px; color: #aaa;">
            選択中: <span id="current-focus" style="color: #fff;">-</span>
        </div>
    </div>
</div>

<div id="bottom-section">
    <div id="mapGrid" class="grid-container"></div>
</div>

<script>
    const RPM_BREAKPOINTS = Array.from({length: 20}, (_, i) => 500 + i * 500);
    const TPS_BREAKPOINTS = Array.from({length: 21}, (_, i) => i * 5);
    let fuelMap = [];
    let selectedR = 5;
    let selectedT = 10;

    function initData() {
        for (let t = 0; t < 21; t++) {
            fuelMap[t] = [];
            for (let r = 0; r < 20; r++) {
                let val = Math.floor(100 + 60 * Math.sin(r/6) * Math.sin(t/10) + (t*2));
                fuelMap[t][r] = val;
            }
        }
    }

    function createCell(text, className) {
        const div = document.createElement('div');
        div.className = 'cell ' + className;
        div.innerText = text;
        return div;
    }

    function renderTable() {
        const container = document.getElementById('mapGrid');
        if (!container) return;
        container.innerHTML = '';

        container.appendChild(createCell('TPS\\RPM', 'header-cell label-cell corner-cell'));
        RPM_BREAKPOINTS.forEach(rpm => container.appendChild(createCell(rpm, 'header-cell')));

        TPS_BREAKPOINTS.forEach((tps, tIdx) => {
            container.appendChild(createCell(tps + '%', 'label-cell'));
            RPM_BREAKPOINTS.forEach((rpm, rIdx) => {
                const val = fuelMap[tIdx][rIdx];
                const cell = document.createElement('div');
                cell.className = 'cell';
                if (tIdx === selectedT && rIdx === selectedR) cell.classList.add('selected-cell');
                else if (tIdx === selectedT || rIdx === selectedR) cell.classList.add('cross-highlight');
                
                let brightness = Math.min(255, val);
                cell.style.backgroundColor = `rgb(${brightness/4}, ${brightness/2}, ${brightness})`;
                cell.style.color = val > 120 ? '#fff' : '#aaa';
                
                const input = document.createElement('input');
                input.type = 'number';
                input.value = val;
                input.id = `input-${tIdx}-${rIdx}`;
                
                input.onfocus = () => { 
                    selectedT = tIdx; 
                    selectedR = rIdx; 
                    renderTable(); 
                    updateGraph(); 
                };
                input.oninput = (e) => { 
                    fuelMap[tIdx][rIdx] = parseInt(e.target.value) || 0; 
                    updateGraph(); 
                };
                
                input.onkeydown = (e) => {
                    let nextT = tIdx;
                    let nextR = rIdx;
                    if (e.key === "ArrowUp") nextT--;
                    else if (e.key === "ArrowDown") nextT++;
                    else if (e.key === "ArrowLeft") nextR--;
                    else if (e.key === "ArrowRight") nextR++;
                    else return;

                    if (nextT >= 0 && nextT < 21 && nextR >= 0 && nextR < 20) {
                        e.preventDefault();
                        const nextInput = document.getElementById(`input-${nextT}-${nextR}`);
                        if (nextInput) nextInput.focus();
                    }
                };

                cell.appendChild(input);
                container.appendChild(cell);
            });
        });
        document.getElementById('current-focus').innerText = `RPM:${RPM_BREAKPOINTS[selectedR]} / TPS:${TPS_BREAKPOINTS[selectedT]}%`;
    }

    function updateGraph() {
        if (typeof Plotly === 'undefined') return;
        const mode = document.querySelector('input[name="viewMode"]:checked').value;
        let data = [];
        let layout = {
            paper_bgcolor: '#1a1a1a', plot_bgcolor: '#000',
            margin: {t:40, l:50, r:30, b:50}, font: {color: '#fff'},
            xaxis: { gridcolor: '#333' }, yaxis: { gridcolor: '#333' }
        };

        if (mode === 'tps') {
            data = [{ x: TPS_BREAKPOINTS, y: fuelMap.map(row => row[selectedR]), type: 'scatter', mode: 'lines+markers', line: {color: '#00ffcc'} }];
        } else if (mode === 'rpm') {
            data = [{ x: RPM_BREAKPOINTS, y: fuelMap[selectedT], type: 'scatter', mode: 'lines+markers', line: {color: '#ffaa00'} }];
        } else if (mode === '3d') {
            data = [{ z: fuelMap, x: RPM_BREAKPOINTS, y: TPS_BREAKPOINTS, type: 'surface', colorscale: 'Viridis' }];
            layout.scene = { xaxis: {title: 'RPM'}, yaxis: {title: 'TPS'}, zaxis: {title: 'Val'} };
        }
        Plotly.react('chart-container', data, layout, {responsive: true, displayModeBar: false});
    }

    function init() {
        initData();
        renderTable();
        const checkPlotly = setInterval(() => {
            if (typeof Plotly !== 'undefined') {
                clearInterval(checkPlotly);
                updateGraph();
            }
        }, 100);
    }

    window.onload = init;
    document.querySelectorAll('input[name="viewMode"]').forEach(r => r.onchange = updateGraph);
</script>
</body>
</html>
